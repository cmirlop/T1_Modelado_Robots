\documentclass[11pt]{article}

%------------------------------------------------------------------
%------------------------------------------------------------------
%------------------------------------------------------------------
% Informació de l'informe

\newcommand{\titol}{
	 Modelado y control cinemático
	 }

\newcommand{\titolcap}{Modelado y control cinemático}

\newcommand{\AlumnoA}{Carlos Mira López}
\newcommand{\AlumnoB}{Nicolás Miró Mira}
\newcommand{\AlumnoC}{Vittorio Alessandro Esposito Ceballos}

\newcommand{\AlumnosPie}{\AlumnoA\ -- \AlumnoB\ -- \AlumnoC}
\newcommand{\Asignatura}{Modelado y Control de Robots}
\newcommand{\CursoTitulacion}{4$.\!^\circ$ curso - Grado en Ingeniería ...}
%https://www.rae.es/dpd/ordinales

\newcommand{\Data}{Diciembre de 2025}

%------------------------------------------------------------------
% Configuració de formats i bibliografia

\input{./configuraciones/preambulo}
\input{./configuraciones/preambulo_listings}

% Si vols utilitzar un tipus de lletra semblant a Arial, descomenta les dos línies següents:
% \usepackage{cmbright}
% \usepackage[OT1]{fontenc}

\bibliography{./configuraciones/referencias}

%------------------------------------------------------------------
% Logo:

\setboolean{LogoUPV}{false}
\setboolean{LogoAlcoi}{true}

%------------------------------------------------------------------
%------------------------------------------------------------------
%------------------------------------------------------------------

\begin{document}

% -------------------------------------
% -------------------------------------

\input{./configuraciones/post_begin_document} % No eliminar!!!

% -------------------------------------
% -------------------------------------


%------------------------------------------------------------------
%------------------------------------------------------------------
% Resumen

%------------------------------------------------------------------
%------------------------------------------------------------------

\section{Introducción}
\label{sec:introduccion}
En este proyecto se diseña y construye un robot manipulador de al menos tres grados de libertad, controlado con servomotores y una placa Arduino UNO. El objetivo es que el robot pueda mover sus articulaciones de manera precisa, calcular la posición del efector final mediante cinemática directa, y determinar los ángulos necesarios para llegar a posiciones deseadas mediante cinemática inversa.
Además, se desarrolla una interfaz de usuario que permite controlar el robot, ver su posición en coordenadas articulares y cartesianas, y enviar comandos de movimiento de forma sencilla.

%------------------------------------------------------------------
%------------------------------------------------------------------

\section{Descripción del diseño mecánico y electrónico}
\label{sec:diseño}
Hemos optado por el diseño y ensamblaje de un robot angular con 3 
grados de libertad, los cuales aparecen como una rotación en la 
base en el eje x, un movimiento horizontal en el eje z con 
respecto a la base gracias a un rodamiento que hemos implementado 
y un movimiento en el eje x del codo del robot, también gracias a 
un rodamiento implementado.




Utilizamos 3 servos, uno bajo la base para realizar el giro, otro 
alineado con el rodamiento del brazo para llevar a cabo el 
movimiento y otro alineado con el rodamiento del codo, también 
para su movimiento. En cuanto al cableado cada servomotor se 
conecta al Arduino mediante tres cables: alimentación (+5V), 
tierra (GND) y señal. Los pines de señal de cada servo se han 
conectado a pines digitales del Arduino, mientras que todas las 
tierras se unifican en común para garantizar un funcionamiento 
estable.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{figuras/imagen_diseño.jpeg}
    \caption{rebot en plenitud}
\end{figure}

Hay varias maneras de definir la posición inicial, nosotros hemos 
optado por definir una posición conocida como es la [0,0,0], donde
 la posición del brazo y del codo son horizontales como se muestra
  en la primera figura, pudiendo calcular así las distancias y 
  facilitar la calibración y el movimiento del robot.
%------------------------------------------------------------------
%------------------------------------------------------------------

\section{Modelo matemático}
\label{sec:modelo}


\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{figuras/imagen_ejes.jpeg}
    \caption{Ejes del robot}
\end{figure}

\[
\begin{array}{c|c|c|c|c}
i & d_i & \theta_i & \alpha_i & a_i \\ \hline
1 & d_1 & 0 & \tfrac{\pi}{2} & 0 \\
2 & 0 & 0 & 0 & d_2 \\
3 & 0 & 0 & 0 & d_3
\end{array}
\]

\subsection{Cinemática directa}
La cinemática directa permite calcular la posición y orientación 
del efector final (la pinza) a partir de los ángulos y 
desplazamientos de las articulaciones del robot.

En nuestro caso, el robot tiene 3 grados de libertad:
\begin{itemize}
    \item Rotación en la base (eje X): permite girar todo el brazo alrededor de la base.
    \item Movimiento horizontal en el eje Z: conseguido mediante un rodamiento implementado en la base, que desplaza el brazo a lo largo del eje Z.
    \item Movimiento en el eje X del codo: logrado mediante otro rodamiento, que permite extender o retraer el brazo a lo largo del eje X desde el codo.

\end{itemize}



La posición del efector final $(x,y,z)$ se calcula combinando 
estas tres transformaciones mediante matrices de transformación 
homogénea. Multiplicando las matrices correspondientes a cada 
articulación se obtiene la matriz global $T_0^3$, de la que se 
extraen las coordenadas de la pinza.

\subsection{Cinemática inversa}
La cinemática inversa permite determinar los ángulos y 
desplazamientos de las articulaciones necesarios para colocar 
la pinza en una posición y orientación deseadas.

Para nuestro robot:
\begin{itemize}
    \item Debemos calcular la rotación de la base para orientar el brazo hacia el punto deseado.
    \item Ajustar el desplazamiento horizontal en Z para posicionar la altura correcta.
    \item Ajustar el movimiento en X del codo para llegar a la distancia correcta desde la base.

\end{itemize}


Se deben considerar posibles múltiples soluciones, así como 
restricciones físicas de los rodillos y límites de las 
articulaciones. La cinemática inversa asegura que el robot pueda 
mover su efector a cualquier posición alcanzable dentro de su 
espacio de trabajo.

%------------------------------------------------------------------
%------------------------------------------------------------------

\section{Código e interfaz}
\label{sec:código}



%------------------------------------------------------------------
\subsection{Código implementado en Arduino}
\begin{lstlisting}[caption={Configuración inicial y variables globales.}, label=lst:vars]
#include <Wire.h>
#include <Adafruit_PWMServoDriver.h>
#include <math.h>

%% Controlador PCA9685
Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver();

%% Canales para cada servo en el PCA9685
#define SERVO_BASE 0
#define SERVO_BRAZO 1
#define SERVO_CODO 2

%% Matriz DH cinematica directa [alpha, a, d, theta]
float Matriz_DH_CD[3][4]; 
const int N = 3;
const int N1 = 4;

%% Matriz resultado
float res_CN[N1][N1];

%% Angulos actuales
int baseAngle = 0;
int brazoAngle = 0;
int codoAngle = 0;

%% Distancia entre ejes
float d1 = 0.075;
float d2 = 0.082;
float d3 = 0.050;

%% Resultados de la cinematica inversa
float theta1, theta2, theta3;
const int step = 5;
int modo = 0; %% 0 = directa, 1 = inversa

%% Mapear angulo a pulso
int angleToPulse(int ang) {
    int pulsoMin = 150; %% 0 grados
    int pulsoMax = 600; %% 180 grados
    return map(ang, 0, 180, pulsoMin, pulsoMax);
}

%% Wrapper para mover servo
void moverServo(int canal, int angulo) {
    int pulso = angleToPulse(angulo);
    pwm.setPWM(canal, 0, pulso);
}
\end{lstlisting}


\begin{lstlisting}[caption={Función de Cinemática Inversa (ik\_RRR).}, label=lst:paso2, language=C++]
%% Función de cinemática inversa RRR
bool ik_RRR(float X, float Y, float Z) {
    const float a2 = d2;
    const float a3 = d3;
    const float h  = d1;

    float th1 = atan2f(Y, X);

    float r = sqrtf(X*X + Y*Y);
    float z = Z - h;

    float D = (r*r + z*z - a2*a2 - a3*a3) / (2.0f * a2 * a3);
    
    %% Verificación de dominio matemático
    if (D > 1.0f) D = 1.0f;
    if (D < -1.0f) D = -1.0f;
    if (isnan(D)) return false;

    float s3 = sqrtf(fmaxf(0.0f, 1.0f - D*D));
    float th3_geom = atan2f(-s3, D);   %% codo abajo

    float num = a3 * sinf(th3_geom);
    float den = a2 + a3 * cosf(th3_geom);
    float th2_geom = atan2f(z, r) - atan2f(num, den);

    const float RAD2DEG = 180.0f / PI;
    float g1 = th1       * RAD2DEG;
    float g2 = th2_geom  * RAD2DEG;
    float g3 = th3_geom  * RAD2DEG;

    %% Normalización de ángulos
    if (g1 < 0.0f) g1 += 360.0f;
    if (g1 > 180.0f) g1 = 360.0f - g1;

    float servo_base  = g1;
    float servo_brazo = g2;
    float servo_codo  = -g3;

    %% Restricción de rango físico
    servo_base  = constrain(servo_base,  0.0f, 180.0f);
    servo_brazo = constrain(servo_brazo, 0.0f, 180.0f);
    servo_codo  = constrain(servo_codo,  0.0f, 180.0f);

    theta1 = servo_base;
    theta2 = servo_brazo;
    theta3 = servo_codo;

    return true;
}
\end{lstlisting}


\begin{lstlisting}[caption={Funciones para manejo de matrices y DH.}, label=lst:paso3, language=C++]
%% Inicializar matriz DH
void inicializar_matriz(){
    Matriz_DH_CD[0][0] =  M_PI/2;
    Matriz_DH_CD[0][1] =  0.0;
    Matriz_DH_CD[0][2] =  d1;
    Matriz_DH_CD[0][3] =  0.0;

    Matriz_DH_CD[1][0] =  0.0;
    Matriz_DH_CD[1][1] =  d2;
    Matriz_DH_CD[1][2] =  0.0;
    Matriz_DH_CD[1][3] =  0.0;

    Matriz_DH_CD[2][0] =  0.0;
    Matriz_DH_CD[2][1] =  d3;
    Matriz_DH_CD[2][2] =  0.0;
    Matriz_DH_CD[2][3] =  0.0;
}

%% Convertir parámetros DH en matriz homogénea
void dh_to_T(float DH[4][4], float alpha, float a, float d, float theta){
    float ca = cos(alpha);
    float sa = sin(alpha);
    float ct = cos(theta);
    float st = sin(theta);

    DH[0][0] = ct;       DH[0][1] = -st * ca;    DH[0][2] = st * sa;     DH[0][3] = a * ct;
    DH[1][0] = st;       DH[1][1] =  ct * ca;    DH[1][2] = -ct * sa;    DH[1][3] = a * st;
    DH[2][0] = 0.0;      DH[2][1] = sa;          DH[2][2] = ca;          DH[2][3] = d;
    DH[3][0] = 0.0;      DH[3][1] = 0.0;         DH[3][2] = 0.0;         DH[3][3] = 1.0;
}

%% Multiplicar matrices 4x4
void multiplicarMatrices(float A[N1][N1], float B[N1][N1], float C[N1][N1]) {
    for (int i = 0; i < N1; i++) {
        for (int j = 0; j < N1; j++) {
            C[i][j] = 0;
            for (int k = 0; k < N1; k++) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
}
\end{lstlisting}


\begin{lstlisting}[caption={Cálculo de la Cinemática Directa.}, label=lst:paso4, language=C++]
%% Calcular cinemática directa
void calcular_directa(){
    float alpha[N], a[N], d[N], theta[N];
    float A1[N1][N1], A2[N1][N1], A3[N1][N1];
    float T0[N1][N1], T1[N1][N1];

    for (int i = 0; i < N; i++) {
        alpha[i] = Matriz_DH_CD[i][0];
        a[i]     = Matriz_DH_CD[i][1];
        d[i]     = Matriz_DH_CD[i][2];
        theta[i] = Matriz_DH_CD[i][3];
    }

    theta[0] += baseAngle * M_PI / 180.0;
    theta[1] += brazoAngle * M_PI / 180.0;
    theta[2] += -codoAngle * M_PI / 180.0;

    dh_to_T(A1, alpha[0], a[0], d[0], theta[0]);
    dh_to_T(A2, alpha[1], a[1], d[1], theta[1]);
    dh_to_T(A3, alpha[2], a[2], d[2], theta[2]);

    float identidad[N1][N1] = {
        {1.0, 0.0, 0.0, 0.0},
        {0.0, 1.0, 0.0, 0.0},
        {0.0, 0.0, 1.0, 0.0},
        {0.0, 0.0, 0.0, 1.0}
    };

    multiplicarMatrices(identidad, A1, T0);
    multiplicarMatrices(T0, A2, T1);
    multiplicarMatrices(T1, A3, res_CN);
}
\end{lstlisting}


\begin{lstlisting}[caption={Configuración (Setup) y Bucle Principal (Loop).}, label=lst:paso5, language=C++]
%% Configuración inicial
void setup() {
    Serial.begin(9600);
    pwm.begin();
    pwm.setPWMFreq(60);

    moverServo(SERVO_BASE, baseAngle);
    moverServo(SERVO_BRAZO, brazoAngle);
    moverServo(SERVO_CODO, codoAngle);

    inicializar_matriz();
}

%% Bucle principal
void loop() {
    if (Serial.available()) {
        String cmd = Serial.readStringUntil('\n');
        cmd.trim();

        if (cmd == "0") {
            modo = 0;
        } 
        else if (cmd == "1") {
            modo = 1;
        }
        %% Modo inverso: SET,X,Y,Z
        else if (cmd.startsWith("SET,") && modo == 1) {
            cmd.remove(0, 4);
            int coma1 = cmd.indexOf(',');
            int coma2 = cmd.lastIndexOf(',');

            if (coma1 > 0 && coma2 > coma1) {
                float b = cmd.substring(0, coma1).toFloat();
                float r = cmd.substring(coma1 + 1, coma2).toFloat();
                float c = cmd.substring(coma2 + 1).toFloat();

                bool func = ik_RRR(b, r, c);
                
                if (func == true){
                    moverServo(SERVO_BASE, theta1);
                    moverServo(SERVO_BRAZO, theta2);
                    moverServo(SERVO_CODO, theta3);
                }
                baseAngle = theta1;
                brazoAngle = theta2;
                codoAngle = theta3;
            }
        }
        %% Controles manuales
        else if (cmd == "Base+" && modo == 0) {
            baseAngle = constrain(baseAngle + step, 0, 180);
            moverServo(SERVO_BASE, baseAngle);
        } 
        else if (cmd == "Base-" && modo == 0) {
            baseAngle = constrain(baseAngle - step, 0, 180);
            moverServo(SERVO_BASE, baseAngle);
        } 
        else if (cmd == "Brazo+" && modo == 0) {
            brazoAngle = constrain(brazoAngle + step, 0, 180);
            moverServo(SERVO_BRAZO, brazoAngle);
        } 
        else if (cmd == "Brazo-" && modo == 0) {
            brazoAngle = constrain(brazoAngle - step, 0, 180);
            moverServo(SERVO_BRAZO, brazoAngle);
        } 
        else if (cmd == "Codo+" && modo == 0) {
            codoAngle = constrain(codoAngle + step, 0, 180);
            moverServo(SERVO_CODO, codoAngle);
        } 
        else if (cmd == "Codo-" && modo == 0) {
            codoAngle = constrain(codoAngle - step, 0, 180);
            moverServo(SERVO_CODO, codoAngle);
        }
    }

    calcular_directa();

    Serial.print(baseAngle);
    Serial.print(",");
    Serial.print(brazoAngle);
    Serial.print(",");
    Serial.print(codoAngle);
    Serial.print(",");
    Serial.print(res_CN[0][3]);
    Serial.print(",");
    Serial.print(res_CN[1][3]);
    Serial.print(",");
    Serial.print(res_CN[2][3]);
    Serial.print("\n");

    delay(500);
}
\end{lstlisting}
%------------------------------------------------------------------
\subsection{Interfaz de usuario}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{figuras/interfaz.jpeg}
    \caption{Interfaz de usuario}
\end{figure}

Esta es la interfaz de usuario que hemos diseñado, tenemos en primera parte un botón para conectar con el robot, junto con un icono de color que nos indica visualmente si la conección ha sido exitosa o no. debajo de eso elegimos el tipo te cinemática, si la opción está pulsada es cinemática directa, en caso contrario es cinemática inversa; debajo de eso tenemos cajas de texto ajustables para base, brazo y codo del robot, todas junto a iconos de + y -, donde podemos mover paso a paso individualmente cada parte en incrementos o decrementos de 5 grados, acompañado con eso debajo cajas de texto que indican las posición del robot en los ejes X Y y Z.

En cuanto a la parte de la cinemática inversa tenemos cajas de texto donde modificamos el valor de las posiciones de X,Y y Z medidas en milímetros, a lo que después presionamos el botón enviar, lo que mueve el robot a las posiciones elegidas, mostrando en las cajas de abajo el ángulo en la base el brazo y el codo, además del resultado del cálculo de la cinemática inversa
\section{Pruebas y demostración}
\label{sec:pruebas}
En esta sección presentaremos pruebas del funcionamiento del robot



\href{https://www.youtube.com/watch?v=iHJcyHrV9w0}{Link a video de cinemática directa}

\href{https://www.youtube.com/watch?v=igmchIDxLEQ}{Link a video de cinemática inversa}

%------------------------------------------------------------------
%------------------------------------------------------------------

\bibitemsep = 2ex
\bibhang = 2em


%------------------------------------------------------------------
%------------------------------------------------------------------
%------------------------------------------------------------------

\end{document}

%------------------------------------------------------------------
%------------------------------------------------------------------
%------------------------------------------------------------------

